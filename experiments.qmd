---
title: "Fair clustering experiments"
execute:
  echo: false
  warning: false
  message: false
---

- [ ] Far capire cosa domina nella complessit√†

```{r}
library(tidyverse)
library(ggpattern)
library(kableExtra)
theme_set(theme_bw() + theme(legend.position="bottom"))

imgdir <- "imgs"

imgpath <- function(key) {
  str_c(imgdir, key, "clustering.png", sep="/")
}

dataset_stats <- function() {
  con <- DBI::dbConnect(RSQLite::SQLite(), "results.db")
  stats <- tbl(con, "dataset_stats") |> collect()
  DBI::dbDisconnect(con)
  stats
}

load_data <- function() {
  con <- DBI::dbConnect(RSQLite::SQLite(), "results.db")

  q <- "select *, json_extract(params, '$.tau') / k as tau,
        cast(additional_metrics -> '$.coreset_radius' as real) as coreset_radius,
        cast(additional_metrics -> '$.time_coreset_s' as real) as coreset_time_s
        from results"

  results <- tbl(con, sql(q)) |> 
    filter(delta == 0) |>
    inner_join(tbl(con, "dataset_stats")) |>
    collect() |>
    mutate(
      timeout_s = if_else(time_s > 30*60, 30*60, timeout_s),
      timed_out = !is.na(timeout_s),
      time_s = if_else(timed_out, timeout_s, time_s),
      scaled_time_spp = time_s / n,
      scaled_coreset_time_spp = coreset_time_s / n,
      img_path = imgpath(hdf5_key),
      coreset_size_frac = tau * k / n,
      dataset = fct_reorder(dataset, desc(n))
    ) |>
    group_by(dataset, k) |>
    mutate(scaled_radius = radius / min(radius, na.rm=T)) |>
    ungroup()

  DBI::dbDisconnect(con)
  results
}

results <- load_data()
dataojs <- results |>
  select(dataset, k, algorithm, tau, radius, time_s, scaled_radius, additive_violation) |>
  group_by(dataset, k, algorithm, tau) |>
  summarise(
    across(c(radius, time_s, scaled_radius), mean),
    additive_violation = max(additive_violation)
  )
ojs_define(data = dataojs)
```


```{r}
dataset_stats() |>
  distinct(dataset, n, dimensions) |>
  arrange(desc(n)) |>
  kbl() |>
  kable_styling()
```

The following grid of plots provides and overview of the radius/time tradeoff for all algorithms.

```{r}
#| column: screen
#| out-width: "100%"
#| fig-width: 15
#| fig-height: 15

results |>
  ggplot(aes(scaled_radius, time_s, color=algorithm, shape=algorithm)) +
  geom_point(data=~ filter(., timed_out), shape=21, color="black", fill="white", size=4) +
  geom_point() +
  facet_grid(vars(dataset), vars(k))
```

This plot instead shows how the radius changes for changing values of `k`.
Notably, the radius flattens earlier when the fairness is considered.
One thing to remember is that, as of now, we are aiming to preserve the _exact_ ratios:
i.e. $\alpha = \beta$, there is no slack in the balancing of each cluster.

```{r}
load_data() |>
  mutate(tau = if_else(is.na(tau), 0, tau)) |>
  ggplot(aes(k, radius, color=algorithm)) +
  geom_line(data=~filter(., algorithm != "coreset-fair-k-center")) +
  geom_point(data=~filter(., algorithm != "coreset-fair-k-center")) +
  geom_line(
    data=~filter(., algorithm == "coreset-fair-k-center"),
    mapping=aes(linetype=factor(tau)),
    stat="summary",
    fun=mean
  ) +
  geom_point(
    data=~filter(., algorithm == "coreset-fair-k-center"),
    mapping=aes(shape=factor(tau)),
    stat="summary",
    fun=mean
  ) +
  scale_y_continuous(limits=c(0,NA)) +
  facet_wrap(vars(dataset), scale="free_y")
```

Here we take a closer look at the performance of our own algorithm: how does the radius change
as the coreset becomes larger and larger?
As expected, it becomes smaller and smaller, approaching the one found by the state 
of the art algorithms.

```{r}
#| fig-cap: Radius of the solution wrt the coreset size
#| fig-cap-location: margin
#| out-width: "100%"
#| fig-width: 10
#| fig-height: 10

load_data() |>
  ggplot(aes(coreset_size_frac, scaled_radius, color=algorithm)) +
  geom_line(data=~drop_na(., coreset_radius), stat="summary") +
  geom_point(data=~drop_na(., coreset_radius), size=1) +
  geom_hline(
    aes(yintercept = scaled_radius, color=algorithm),
    data=~filter(., algorithm != "coreset-fair-k-center")
  ) +
  scale_y_continuous(limits=c(1,NA)) +
  scale_x_continuous(limits=c(0,1), labels=scales::percent) +
  facet_grid(vars(dataset), vars(factor(k)), scales="free")
```

Notable things in @fig-time are that the KFC algorithm has some sudden jumps in the running 
time with increases in $k$, due to changes in the _joiners_ structure as $k$ increases: the 
radius becomes smaller hence the problem becomes larger.

```{r}
#| label: fig-time
#| fig-cap: Running time
#| out-width: "100%"
#| fig-width: 10
#| fig-height: 10

filterfn <- function(dat) {
  dat |>
    filter(coreset_size_frac <= 1) |>
    drop_na(coreset_size_frac)
}

load_data() |>
  ggplot(aes(y=time_s, color=algorithm, fill=algorithm)) +
  geom_line(aes(x=coreset_size_frac), data=filterfn, stat="summary") +
  geom_area(aes(x=coreset_size_frac, y=time_s), data=filterfn, alpha=0.2, stat="summary") +
  geom_area(aes(x=coreset_size_frac, y=coreset_time_s), data=filterfn, stat="summary") +
  # geom_point(data=filterfn, size=1) +
  geom_hline(
    aes(yintercept = time_s, color=algorithm, fill=algorithm),
    data=~filter(., algorithm != "coreset-fair-k-center")
  ) +
  scale_x_continuous(limits=c(0,1), labels=scales::percent) +
  facet_grid(vars(dataset), vars(factor(k)), scales="free")
```

```{r}
#| fig-width: 7
#| fig-height: 10
load_data() |>
  ggplot(aes(x=k, y=additive_violation, color=algorithm)) +
  geom_point(position="dodge") +
  scale_x_continuous(trans="log2") +
  facet_wrap(vars(dataset), scales="free", ncol=2)
```

```{ojs}
viewof dataset = Inputs.radio(new Set(data.dataset), {label: "Dataset", value: "census1990"})
viewof kval = Inputs.radio(new Set(data.k), {label: "K", value: 2})
```

```{ojs}
plotdata = transpose(data).filter(r => r.dataset == dataset && r.k == kval)
Plot.plot({
  color: {legend: true},
  x: {grid: true},
  y: {domain: [0, d3.max(plotdata, d => d.time_s)], grid: true},
  marks: [
    Plot.dot(
      plotdata,
      {
        x: "radius",
        y: "time_s",
        fill: "algorithm",
        stroke: "algorithm",
        tip: true
      }
    )
  ]
})
```

```{ojs}
viewof search = Inputs.search(
  transpose(data).filter(r => r.dataset == dataset && r.k == kval)
)
```

```{ojs}
Inputs.table(search)
```


